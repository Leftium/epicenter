# Suspended Tabs

**Date**: 2026-02-13
**Status**: Draft
**Supersedes**: `20260212T132200-events-based-tab-management.md`

## Overview

Add a `suspended_tabs` table alongside the existing `tabs` table. Users can explicitly suspend tabs (close from browser, save to Yjs) and restore them later from any device. No cross-device command dispatch needed.

## Motivation

### Current State

The tab manager syncs live browser tabs across devices via Yjs CRDTs. Each device writes its own tab rows (device-scoped). This works well for **viewing** tabs across devices, but there's no way to:

1. **Save a tab for later** — closing a tab removes it from the `tabs` table permanently
2. **Declutter without losing tabs** — users must choose between keeping a tab open or losing it
3. **Organize saved tabs** — no persistent, editable collection of "parked" tabs

### What Changed From the Events-Based Spec

The events-based spec (`20260212T132200`) introduced a commands table for cross-device tab operations (remote close, remote create). After analysis, the core use case doesn't require remote device control:

- **Remote close**: Not needed. Users don't want to close tabs on other devices remotely.
- **Remote create**: Not needed. Restoring a suspended tab opens it locally on whichever device initiates the restore.

Without cross-device commands, the entire commands table, command processor, and overlay system are unnecessary. What remains is the simpler and more useful feature: **suspend and restore**.

### Why Not Awareness?

We evaluated using Yjs Awareness for live tab state (ephemeral, no persistence). Analysis of the `y-protocols/awareness.js` source revealed:

| Dimension              | Awareness                              | YKeyValueLww (current)       |
| ---------------------- | -------------------------------------- | ---------------------------- |
| Wire format            | `JSON.stringify(fullState)` per update | CRDT binary delta (~2 bytes) |
| One tab title change   | Re-sends all 50-100 tabs (~15-30KB)    | ~2 bytes incremental         |
| Idle heartbeat         | Full state every 15 seconds            | Nothing                      |
| Browser dormancy       | State vanishes (30s timeout)           | Persists in Y.Doc            |
| GC after delete cycles | N/A                                    | Y.Doc returns to ~100 bytes  |

The existing per-tab-row architecture with YKeyValueLww is 10,000x more efficient for incremental sync. Awareness is designed for small payloads (cursors, usernames), not 50-100 tab objects per client.

## Design Decisions

| Decision              | Choice                     | Rationale                                                     |
| --------------------- | -------------------------- | ------------------------------------------------------------- |
| Live tab storage      | Keep existing `tabs` table | Already works, efficient incremental sync                     |
| Suspended tab storage | New `suspended_tabs` table | Shared via Yjs, any device can read/edit/restore              |
| Cross-device commands | None                       | No use case for remote device control                         |
| Suspend action        | Local only                 | Device closes its own tab + writes to `suspended_tabs`        |
| Restore action        | Local only                 | Any device creates tab locally + deletes `suspended_tabs` row |
| Awareness             | Presence only (future)     | "Is device online?" UX hints, not tab state                   |

## Architecture

### Two Tables, Clear Semantics

```
┌─────────────────────────────────────────────────────────────┐
│  tabs table (live browser state, device-owned)               │
│                                                              │
│  - Each device writes/deletes its own rows                   │
│  - Other devices READ only                                   │
│  - Cleaned up on browser restart via refetchTabs() diff      │
│  - Unchanged from current implementation                     │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│  suspended_tabs table (saved tabs, shared)                   │
│                                                              │
│  - Created when user explicitly suspends a tab               │
│  - Any device can read, edit, or restore                     │
│  - Survives browser restarts, device offline, etc.           │
│  - Restored = browser.tabs.create() + delete row             │
└─────────────────────────────────────────────────────────────┘
```

### Action Flows

**Suspend a tab:**

```
User clicks "Suspend" on Tab X
  │
  ├─ 1. Read tab data (url, title, favIconUrl, pinned)
  │
  ├─ 2. Write to suspended_tabs table:
  │     { id: nanoid(), url, title, fav_icon_url, pinned,
  │       source_device_id, suspended_at }
  │
  └─ 3. Close the browser tab:
        browser.tabs.remove(tabId)
        (onRemoved handler deletes from tabs table as usual)
```

**Restore a suspended tab:**

```
User clicks "Restore" on Suspended Tab Y (from any device)
  │
  ├─ 1. Read suspended tab data (url, pinned)
  │
  ├─ 2. Create browser tab locally:
  │     browser.tabs.create({ url, pinned })
  │     (onCreated handler adds to tabs table as usual)
  │
  └─ 3. Delete from suspended_tabs:
        tables.suspended_tabs.delete(id)
```

**Edit a suspended tab:**

```
User edits URL or title of Suspended Tab Y (from any device)
  │
  └─ Direct table write:
     tables.suspended_tabs.set({ ...existing, url: newUrl })
     (Syncs to all devices via Yjs automatically)
```

### What Stays Unchanged

The entire existing `background.ts` sync layer remains as-is:

- Browser event listeners (onCreated, onRemoved, onUpdated, etc.)
- Y.Doc observers for remote changes
- `syncCoordination` counters
- `refetchTabs()` / `refetchWindows()` / `refetchTabGroups()`
- Device registration
- Keepalive alarm

No modifications to the existing bidirectional sync. The `suspended_tabs` table is purely additive.

## Schema

### Suspended Tabs Table

```typescript
const suspended_tabs = defineTable(
	type({
		id: 'string', // nanoid, generated on suspend
		url: 'string', // The tab URL
		title: 'string', // Tab title at time of suspend
		'fav_icon_url?': 'string', // Favicon URL (nullable)
		pinned: 'boolean', // Whether tab was pinned
		source_device_id: 'string', // Device that suspended this tab
		suspended_at: 'number', // Timestamp (ms since epoch)
	}),
);
```

**Why these fields:**

- `url` + `title`: Core data needed to restore and display the tab
- `fav_icon_url`: Visual identification in the UI (optional because not all tabs have one)
- `pinned`: Restore in the same pinned state
- `source_device_id`: Know which device it came from (informational, not access control)
- `suspended_at`: Sort by recency, potential future cleanup

**Why NOT these fields:**

- `tab_id`: Meaningless after close (browser assigns new IDs)
- `window_id`: Window context lost after close
- `group_id` / `group_name`: Tab group context is ephemeral; could add later if needed
- `active` / `highlighted` / `discarded` / `audible` / `muted`: Runtime state, irrelevant for suspended tabs
- `status` / `index` / `incognito` / `auto_discardable` / `opener_tab_id`: Same reasoning

### Updated BROWSER_TABLES Export

```typescript
export const BROWSER_TABLES = {
	devices,
	tabs,
	windows,
	tab_groups,
	suspended_tabs, // New
};
```

## Implementation Plan

### Phase 1: Schema

- [ ] **1.1** Add `suspended_tabs` table definition to `browser.schema.ts`
- [ ] **1.2** Export in `BROWSER_TABLES`
- [ ] **1.3** Add type export (`SuspendedTab`)

### Phase 2: Suspend Action

- [ ] **2.1** Create `suspend-tab.ts` helper — reads tab data, writes to `suspended_tabs`, closes browser tab
- [ ] **2.2** Wire into popup UI — add "Suspend" button/action per tab in `TabItem.svelte`

### Phase 3: Restore Action

- [ ] **3.1** Create `restore-tab.ts` helper — creates browser tab from suspended data, deletes `suspended_tabs` row
- [ ] **3.2** Wire into popup UI — suspended tabs list with "Restore" action

### Phase 4: Suspended Tabs UI

- [ ] **4.1** Add suspended tabs section to popup (list of suspended tabs)
- [ ] **4.2** Show source device name, suspended time
- [ ] **4.3** Allow editing URL/title inline (direct table write)
- [ ] **4.4** Bulk restore / bulk delete actions

### Phase 5: Awareness for Presence (Future)

- [ ] **5.1** Publish device online status via awareness protocol
- [ ] **5.2** Use presence for UX hints in popup ("Device B is online")

This phase is unchanged from the events-based spec. Awareness is used strictly for presence, never for tab state.

## Edge Cases

### Suspend During Browser Restart

1. User clicks "Suspend" on a tab
2. `suspended_tabs.set(...)` succeeds
3. `browser.tabs.remove(tabId)` fails (browser shutting down)
4. Tab is both in `suspended_tabs` AND `tabs` briefly
5. On restart, `refetchTabs()` removes stale tab rows — no conflict

### Restore When Tab Already Exists

1. User restores a suspended tab (URL: example.com)
2. `browser.tabs.create({ url })` opens a new tab
3. `suspended_tabs.delete(id)` removes the saved version
4. If user already had example.com open — now they have two. This is correct behavior (suspend/restore is about tab slots, not URL deduplication).

### Edit Conflicts (Two Devices Edit Same Suspended Tab)

1. Device A edits title of suspended tab X
2. Device B edits URL of suspended tab X simultaneously
3. YKeyValueLww LWW resolution: later timestamp wins (entire row replaced)
4. One edit may be lost. This is acceptable for v1 — suspended tab edits are rare and low-stakes.

### Large Number of Suspended Tabs

Per the benchmark data:

- 1,000 suspended tabs ≈ 75KB Y.Doc size
- Delete all → Y.Doc returns to ~100 bytes (GC)
- No practical concern for typical usage (tens of suspended tabs)

## Success Criteria

- [ ] User can suspend a tab from the popup (closes tab, saves to `suspended_tabs`)
- [ ] Suspended tabs visible from any connected device
- [ ] User can restore a suspended tab (opens URL locally, removes from `suspended_tabs`)
- [ ] User can edit a suspended tab's URL or title
- [ ] User can bulk-restore or bulk-delete suspended tabs
- [ ] Existing live tab sync is completely unaffected
- [ ] `suspended_tabs` survives browser restarts and device offline

## References

- `apps/tab-manager/src/lib/epicenter/browser.schema.ts` — Current table definitions
- `apps/tab-manager/src/entrypoints/background.ts` — Current sync logic (unchanged)
- `packages/epicenter/src/shared/y-keyvalue/y-keyvalue-lww.ts` — YKeyValueLww implementation
- `packages/epicenter/src/static/benchmark.test.ts` — Performance benchmarks
- `packages/epicenter/src/server/sync/index.ts` — Awareness protocol on server
- `node_modules/y-protocols/awareness.js` — Awareness source (JSON.stringify per update, no delta)
- `specs/20260212T132200-events-based-tab-management.md` — Superseded spec
