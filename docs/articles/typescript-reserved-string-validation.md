# Return Object Types for Readable Compile-Time Rejections

**TL;DR**: When rejecting specific string literals at compile time, **return an object type containing your message, not `never`**. TypeScript shows the expected type in errors; if that type contains your message, developers see it.

> The key insight: TypeScript's error says "X is not assignable to type Y". Make Y be your error message.

See [`typescript-reserved-string-validation.ts`](./typescript-reserved-string-validation.ts) for a runnable reproduction.

## The Broken Pattern

```typescript
type ValidFieldId<T extends string> = T extends 'id' ? never : T;

declare function text<const K extends string>(opts: {
	id: ValidFieldId<K>;
}): void;

text({ id: 'id' });
// Error: Type 'string' is not assignable to type 'never'.
```

Useless. Doesn't say WHY 'id' is forbidden.

## Pattern 1: Object with `__error` Property

The simplest fix: return an object type with your message in a property.

```typescript
type FieldError<Message extends string> = {
	readonly __error: Message;
};

type ValidFieldId<K extends string> = K extends 'id' | 'createdAt' | 'updatedAt'
	? FieldError<`"${K}" is reserved - auto-generated by system`>
	: K extends `_${string}`
		? FieldError<`"${K}" - underscore prefix is internal`>
		: K extends `$${string}`
			? FieldError<`"${K}" - dollar prefix is for computed fields`>
			: K;

declare function text<const K extends string>(opts: {
	id: ValidFieldId<K>;
}): void;

text({ id: 'id' });
// Error: Type 'string' is not assignable to type
//        'FieldError<"\"id\" is reserved - auto-generated by system">'.

text({ id: 'createdAt' });
// Error: Type 'string' is not assignable to type
//        'FieldError<"\"createdAt\" is reserved - auto-generated by system">'.

text({ id: '_private' });
// Error: Type 'string' is not assignable to type
//        'FieldError<"\"_private\" - underscore prefix is internal">'.

text({ id: '$computed' });
// Error: Type 'string' is not assignable to type
//        'FieldError<"\"$computed\" - dollar prefix is for computed fields">'.

text({ id: 'title' }); // OK
text({ id: 'email' }); // OK
```

## Pattern 2: Named Error Type

Make the type NAME itself descriptive; it appears in the error message.

```typescript
type RESERVED_FIELD<Field extends string, Reason extends string> = {
	readonly __field: Field;
	readonly __reason: Reason;
};

type INTERNAL_FIELD<Field extends string> = {
	readonly __field: Field;
	readonly __reason: 'underscore prefix is reserved for internal fields';
};

type COMPUTED_FIELD<Field extends string> = {
	readonly __field: Field;
	readonly __reason: 'dollar prefix is reserved for computed fields';
};

type ValidFieldId<K extends string> = K extends 'id' | 'createdAt' | 'updatedAt'
	? RESERVED_FIELD<K, 'auto-generated by system'>
	: K extends `_${string}`
		? INTERNAL_FIELD<K>
		: K extends `$${string}`
			? COMPUTED_FIELD<K>
			: K;

declare function text<const K extends string>(opts: {
	id: ValidFieldId<K>;
}): void;

text({ id: 'id' });
// Error: Type 'string' is not assignable to type
//        'RESERVED_FIELD<"id", "auto-generated by system">'.

text({ id: 'createdAt' });
// Error: Type 'string' is not assignable to type
//        'RESERVED_FIELD<"createdAt", "auto-generated by system">'.

text({ id: '_private' });
// Error: Type 'string' is not assignable to type 'INTERNAL_FIELD<"_private">'.

text({ id: '$computed' });
// Error: Type 'string' is not assignable to type 'COMPUTED_FIELD<"$computed">'.
```

## Pattern 3: Symbol Brand (wellcrafted style)

Use a unique symbol for guaranteed type uniqueness, combined with readable error properties.

```typescript
// Symbol-based brand (same implementation as wellcrafted/brand)
declare const brand: unique symbol;
type Brand<T extends string> = { [brand]: { [K in T]: true } };

// Combine brand with readable error object
type SchemaError<Code extends string, Message extends string> = {
	readonly __errorCode: Code;
	readonly __message: Message;
} & Brand<`SchemaError:${Code}`>;

type ValidFieldId<K extends string> = K extends 'id' | 'createdAt' | 'updatedAt'
	? SchemaError<
			'RESERVED_FIELD',
			`"${K}" is reserved - auto-generated by system`
		>
	: K extends `_${string}`
		? SchemaError<'INTERNAL_FIELD', `"${K}" - underscore prefix is internal`>
		: K extends `$${string}`
			? SchemaError<
					'COMPUTED_FIELD',
					`"${K}" - dollar prefix is for computed fields`
				>
			: K;

declare function text<const K extends string>(opts: {
	id: ValidFieldId<K>;
}): void;

text({ id: 'id' });
// Error: Type 'string' is not assignable to type
//        'SchemaError<"RESERVED_FIELD", "\"id\" is reserved - auto-generated by system">'.

text({ id: 'createdAt' });
// Error: Type 'string' is not assignable to type
//        'SchemaError<"RESERVED_FIELD", "\"createdAt\" is reserved - auto-generated by system">'.

text({ id: '_private' });
// Error: Type 'string' is not assignable to type
//        'SchemaError<"INTERNAL_FIELD", "\"_private\" - underscore prefix is internal">'.

text({ id: '$computed' });
// Error: Type 'string' is not assignable to type
//        'SchemaError<"COMPUTED_FIELD", "\"$computed\" - dollar prefix is for computed fields">'.
```

## Comparison

| Pattern            | Error Shows                      | Uniqueness          | Dependencies          |
| ------------------ | -------------------------------- | ------------------- | --------------------- |
| `__error` property | `FieldError<"message">`          | Property name       | None                  |
| Named error type   | `RESERVED_FIELD<"id", "reason">` | Type name           | None                  |
| Symbol brand       | `SchemaError<"CODE", "message">` | Symbol (guaranteed) | wellcrafted or inline |

All three patterns work. Choose based on:

- **`__error` property**: Simplest; message in property value
- **Named error type**: Type name itself signals the problem
- **Symbol brand**: Guaranteed uniqueness; structured error codes for programmatic handling

## Why It Works

TypeScript error messages follow the pattern: "Type X is not assignable to type Y".

When the expected parameter type is `never`, Y is "never" and the error is useless. When the expected type is an object containing your message, Y shows that type alias with your message inside.

The object type is impossible for a string to satisfy, so TypeScript correctly rejects it and shows the full type in the error.
