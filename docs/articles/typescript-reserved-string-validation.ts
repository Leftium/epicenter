/**
 * Minimal reproduction for typescript-reserved-string-validation.md
 *
 * Run: bunx tsc --noEmit docs/articles/typescript-reserved-string-validation.ts
 *
 * This file demonstrates three patterns for compile-time field ID validation
 * with readable error messages. Each pattern shows four error cases:
 * - 'id' (reserved, auto-generated)
 * - 'createdAt' (reserved, auto-generated)
 * - '_private' (underscore prefix is internal)
 * - '$computed' (dollar prefix is for computed fields)
 */

// ============================================================================
// THE BROKEN PATTERN (returns `never` - useless error messages)
// ============================================================================

type ValidFieldId_Broken<T extends string> = T extends 'id' ? never : T;

declare function text_broken<const K extends string>(opts: {
	id: ValidFieldId_Broken<K>;
}): void;

// Error: Type 'string' is not assignable to type 'never'.
text_broken({ id: 'id' });

// ============================================================================
// PATTERN 1: Object with `__error` Property
// ============================================================================

type FieldError<Message extends string> = {
	readonly __error: Message;
};

type ValidFieldId_Pattern1<K extends string> = K extends
	| 'id'
	| 'createdAt'
	| 'updatedAt'
	? FieldError<`"${K}" is reserved - auto-generated by system`>
	: K extends `_${string}`
		? FieldError<`"${K}" - underscore prefix is internal`>
		: K extends `$${string}`
			? FieldError<`"${K}" - dollar prefix is for computed fields`>
			: K;

declare function text_pattern1<const K extends string>(opts: {
	id: ValidFieldId_Pattern1<K>;
}): void;

// Error: Type 'string' is not assignable to type
//        'FieldError<"\"id\" is reserved - auto-generated by system">'.
text_pattern1({ id: 'id' });

// Error: Type 'string' is not assignable to type
//        'FieldError<"\"createdAt\" is reserved - auto-generated by system">'.
text_pattern1({ id: 'createdAt' });

// Error: Type 'string' is not assignable to type
//        'FieldError<"\"_private\" - underscore prefix is internal">'.
text_pattern1({ id: '_private' });

// Error: Type 'string' is not assignable to type
//        'FieldError<"\"$computed\" - dollar prefix is for computed fields">'.
text_pattern1({ id: '$computed' });

// Valid cases - no errors
text_pattern1({ id: 'title' });
text_pattern1({ id: 'email' });

// ============================================================================
// PATTERN 2: Named Error Type
// ============================================================================

type RESERVED_FIELD<Field extends string, Reason extends string> = {
	readonly __field: Field;
	readonly __reason: Reason;
};

type INTERNAL_FIELD<Field extends string> = {
	readonly __field: Field;
	readonly __reason: 'underscore prefix is reserved for internal fields';
};

type COMPUTED_FIELD<Field extends string> = {
	readonly __field: Field;
	readonly __reason: 'dollar prefix is reserved for computed fields';
};

type ValidFieldId_Pattern2<K extends string> = K extends
	| 'id'
	| 'createdAt'
	| 'updatedAt'
	? RESERVED_FIELD<K, 'auto-generated by system'>
	: K extends `_${string}`
		? INTERNAL_FIELD<K>
		: K extends `$${string}`
			? COMPUTED_FIELD<K>
			: K;

declare function text_pattern2<const K extends string>(opts: {
	id: ValidFieldId_Pattern2<K>;
}): void;

// Error: Type 'string' is not assignable to type
//        'RESERVED_FIELD<"id", "auto-generated by system">'.
text_pattern2({ id: 'id' });

// Error: Type 'string' is not assignable to type
//        'RESERVED_FIELD<"createdAt", "auto-generated by system">'.
text_pattern2({ id: 'createdAt' });

// Error: Type 'string' is not assignable to type 'INTERNAL_FIELD<"_private">'.
text_pattern2({ id: '_private' });

// Error: Type 'string' is not assignable to type 'COMPUTED_FIELD<"$computed">'.
text_pattern2({ id: '$computed' });

// Valid cases - no errors
text_pattern2({ id: 'title' });
text_pattern2({ id: 'email' });

// ============================================================================
// PATTERN 3: Symbol Brand (wellcrafted style)
// ============================================================================

declare const brand: unique symbol;
type Brand<T extends string> = { [brand]: { [K in T]: true } };

type SchemaError<Code extends string, Message extends string> = {
	readonly __errorCode: Code;
	readonly __message: Message;
} & Brand<`SchemaError:${Code}`>;

type ValidFieldId_Pattern3<K extends string> = K extends
	| 'id'
	| 'createdAt'
	| 'updatedAt'
	? SchemaError<'RESERVED_FIELD', `"${K}" is reserved - auto-generated by system`>
	: K extends `_${string}`
		? SchemaError<'INTERNAL_FIELD', `"${K}" - underscore prefix is internal`>
		: K extends `$${string}`
			? SchemaError<'COMPUTED_FIELD', `"${K}" - dollar prefix is for computed fields`>
			: K;

declare function text_pattern3<const K extends string>(opts: {
	id: ValidFieldId_Pattern3<K>;
}): void;

// Error: Type 'string' is not assignable to type
//        'SchemaError<"RESERVED_FIELD", "\"id\" is reserved - auto-generated by system">'.
text_pattern3({ id: 'id' });

// Error: Type 'string' is not assignable to type
//        'SchemaError<"RESERVED_FIELD", "\"createdAt\" is reserved - auto-generated by system">'.
text_pattern3({ id: 'createdAt' });

// Error: Type 'string' is not assignable to type
//        'SchemaError<"INTERNAL_FIELD", "\"_private\" - underscore prefix is internal">'.
text_pattern3({ id: '_private' });

// Error: Type 'string' is not assignable to type
//        'SchemaError<"COMPUTED_FIELD", "\"$computed\" - dollar prefix is for computed fields">'.
text_pattern3({ id: '$computed' });

// Valid cases - no errors
text_pattern3({ id: 'title' });
text_pattern3({ id: 'email' });
